# ========================================
# LOGSTASH CONFIGURATION - SUIVI COMMANDES B2B
# Production-ready - Orange Maroc
# Version: 2.1 (Corrigée - Regex + Deprecated)
# ========================================

input {
  file {
    path => "/var/log/app/*.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/.sincedb_appvendeur"
    codec => multiline {
      pattern => '^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}'
      negate => true
      what => "previous"
    }
    type => "appvendeur_b2b"
  }
}

filter {
  # === ÉTAPE 1 : EXTRACTION MÉTADONNÉES DE BASE ===
  grok {
    match => {
      "message" => [
        # Pattern principal pour logs applicatifs
        "%{TIMESTAMP_ISO8601:log_timestamp}\s+\[%{DATA:thread}\]\s+%{LOGLEVEL:log_level}\s+%{JAVACLASS:logger}\s+-\s+\[%{UUID:correlation_id}\s+-\s+%{DATA:username}\]\s+(?<log_message>.*)"
      ]
    }
    tag_on_failure => ["_grok_parse_failure_base"]
  }

  # === ÉTAPE 2 : DÉTECTION DU TYPE D'ÉVÉNEMENT ===
  if [log_message] =~ /Exit OrderResource\.getAllOrders/ {
    mutate { add_tag => ["order_list"] }
  }
  
  if [log_message] =~ /Exit OrderResource\.(createOrder|updateOrder|validateOrder)/ {
    mutate { add_tag => ["order_action"] }
  }
  
  if [log_message] =~ /workflowStepDTO/ {
    mutate { add_tag => ["workflow_transition"] }
  }
  
  if [log_message] =~ /orderDocumentsDTOs/ {
    mutate { add_tag => ["document_validation"] }
  }
  
  if [log_level] == "ERROR" {
    mutate { add_tag => ["error"] }
  }

  # === ÉTAPE 3 : PARSING JSON SPÉCIFIQUE COMMANDES ===
  if "order_action" in [tags] or "workflow_transition" in [tags] or "document_validation" in [tags] or "order_list" in [tags] {
    # Extraction du JSON embarqué dans le log
    grok {
      match => { "log_message" => "result:\s*%{GREEDYDATA:json_payload}" }
      tag_on_failure => []
    }
    
    if [json_payload] {
      json {
        source => "json_payload"
        target => "order_data"
        tag_on_failure => ["_json_parse_failure"]
      }
    }
  }

  # === ÉTAPE 4 : EXTRACTION CHAMPS MÉTIER (VERSION ROBUSTE) ===
  if [order_data] {
    ruby {
      code => '
        begin
          content = event.get("[order_data][body][content]")
          if content.is_a?(Array) && content.first
            order = content.first
            
            # Extraction métadonnées principales
            event.set("order_id", order["id"].to_s) if order["id"]
            event.set("total_amount", order["totalAmount"]) if order["totalAmount"]
            event.set("is_risk", order["isRisk"]) if order.key?("isRisk")
            event.set("config_type", order["configType"]) if order["configType"]
            event.set("technologie", order["technologie"]) if order["technologie"]
            
            # Workflow
            workflow = order["workflowStepDTO"]
            if workflow
              event.set("workflow_code", workflow["code"]) if workflow["code"]
              event.set("workflow_substatus", workflow["subStatus"]) if workflow["subStatus"]
            end
            
            # Produit principal
            items = order["orderItemDetailsDTOs"]
            if items.is_a?(Array) && items.first
              event.set("product_name", items.first["productName"]) if items.first["productName"]
              
              # MSISDN
              config_fields = items.first["orderItemConfigFieldDetailsDTOs"]
              if config_fields.is_a?(Array)
                msisdn_field = config_fields.find { |f| f["fieldName"] == "MSISDN" }
                event.set("msisdn", msisdn_field["fieldValue"]) if msisdn_field
              end
            end
          end
        rescue => e
          event.tag("_ruby_order_extraction_error")
        end
      '
    }
    
    # Nettoyage valeurs "null" (string)
    if [config_type] in ["null", ""] {
      mutate { remove_field => ["config_type"] }
    }
    if [technologie] in ["null", ""] {
      mutate { remove_field => ["technologie"] }
    }
    if [workflow_code] in ["null", ""] {
      mutate { remove_field => ["workflow_code"] }
    }
    if [workflow_substatus] in ["null", ""] {
      mutate { remove_field => ["workflow_substatus"] }
    }
    
    # Calcul du statut global de la commande
    ruby {
      code => '
        workflow_code = event.get("workflow_code")
        workflow_sub = event.get("workflow_substatus")
        
        if workflow_code.nil? || workflow_code == ""
          status = "UNKNOWN"
        elsif workflow_code == "TO_COMPLETE"
          status = "PENDING_DOCUMENTS"
        elsif workflow_code == "EN_COURS" && workflow_sub == "STUDY_RISK"
          status = "UNDER_RISK_REVIEW"
        elsif workflow_code == "EN_COURS" && workflow_sub == "INTERNAL_PROCESSING"
          status = "PROCESSING"
        elsif workflow_code =~ /VALIDATED|COMPLETED/
          status = "VALIDATED"
        else
          status = "IN_PROGRESS"
        end
        
        event.set("order_status", status)
      '
    }
  }

  # === ÉTAPE 4.5 : EXTRACTION EXECUTION_TIME ===
  if [log_message] {
    grok {
      match => { 
        "log_message" => [
          "took %{NUMBER:execution_time}ms",
          "execution time[:\s]+%{NUMBER:execution_time}",
          "duration[:\s]+%{NUMBER:execution_time}"
        ]
      }
      tag_on_failure => []
    }
  }

  # === ÉTAPE 5 : DÉTECTION ÉCHECS & ERREURS ===
  mutate {
    add_field => { "action_status" => "SUCCESS" }
  }
  
  if "error" in [tags] or [log_level] == "ERROR" {
    mutate { replace => { "action_status" => "FAILURE" } }
    
    # Extraction code/message erreur spécifique
    if [log_message] =~ /error response/ or [log_message] =~ /exception/ {
      grok {
        match => {
          "log_message" => [
            "code\"\s*:\s*\"%{DATA:error_code}\",\s*\"message\"\s*:\s*\"%{DATA:error_message}\"",
            "message\"\s*:\s*\"%{DATA:error_message}\"",
            "Exception:\s*%{DATA:error_message}"
          ]
        }
        tag_on_failure => []
      }
    }
  }
  
  # Détection documents invalides
  if "document_validation" in [tags] and [order_data] {
    ruby {
      code => '
        begin
          docs = event.get("[order_data][body][content][0][orderDocumentsDTOs]")
          if docs.is_a?(Array)
            invalid_docs = docs.select { |d| d["valid"] == false || d["toComplet"] == true }
            if invalid_docs.any?
              event.set("has_invalid_documents", true)
              event.set("invalid_document_types", invalid_docs.map { |d| d["type"] }.join(","))
              event.set("action_status", "FAILURE") if event.get("action_status") == "SUCCESS"
            else
              event.set("has_invalid_documents", false)
            end
          end
        rescue => e
          event.tag("_ruby_document_validation_error")
        end
      '
    }
  }

  # === ÉTAPE 6 : NORMALISATION & NETTOYAGE ===
  date {
    match => [ "log_timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
    target => "@timestamp"
  }
  
  mutate {
    # Conversion types
    convert => {
      "total_amount" => "float"
      "is_risk" => "boolean"
      "execution_time" => "integer"
    }
    
    # Normalisation username (masquage sensible)
    gsub => [
      "username", "^AppVnd_", "SELLER_",
      "username", "^bo", "BACKOFFICE_"
    ]
  }

  # === ÉTAPE 7 : ENRICHISSEMENT MÉTIER ===
  if [config_type] {
    translate {
      source => "config_type"
      target => "operation_type"
      dictionary => {
        "ACQUISITION" => "New subscription"
        "PORTABILITE" => "Number portability"
        "MIGRATION" => "Plan migration"
        "RENEWAL" => "Contract renewal"
      }
      fallback => "Other"
    }
  }
  
  if [technologie] {
    translate {
      source => "technologie"
      target => "technology_type"
      dictionary => {
        "MOBILE" => "Mobile"
        "FIXE" => "Fixed line"
        "INT" => "Internet"
      }
      fallback => "Other"
    }
  }

  # === NETTOYAGE FINAL (après tous les parsings) ===
  mutate {
    remove_field => [
      "host", "path", "log_timestamp", "log_message",
      "json_payload", "order_data", "logger", "thread", "message"
    ]
  }
}

output {
  # === SORTIE PRINCIPALE : ELASTICSEARCH ===
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "appvendeur-orders-%{+YYYY.MM.dd}"
    document_id => "%{correlation_id}"
    
    # Mapping explicite pour performances
    template_name => "appvendeur-orders"
    template => "/usr/share/logstash/templates/appvendeur-orders-template.json"
    template_overwrite => true
    
    # Gestion erreurs production
    retry_initial_interval => 2
    retry_max_interval => 64
    retry_on_conflict => 3
    action => "index"
  }

  # === SORTIE DEBUG (activer si besoin) ===
  # stdout { codec => rubydebug { metadata => false } }
}